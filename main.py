from contextlib import asynccontextmanager
import logging
from fastapi import Depends, FastAPI, HTTPException
from database import Base, SessionLocal, create_tables
from sqlalchemy.orm import Session

# Importing the database model and Pydantic schemas for data validation
from model import TaskDB
from schemas import (
    GetAllTasksResponse, GetTaskByIdResponse, NewTaskRequest, 
    NewTaskResponse, Tasks, UpdateTaskByIdRequest, UpdateTaskByIdResponse
)

# Setup a logger using the uvicorn standard to see application logs in the console
logger = logging.getLogger('uvicorn')

# Lifespan manager: logic that runs once during app startup and shutdown
@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info('---------------------------')
    logger.info('Initiating the application')
    logger.info('---------------------------')
    # Automatically creates database tables based on SQLAlchemy models
    create_tables()
    yield  # The app runs while execution is paused here
    
# Initialize FastAPI with a base prefix and the lifecycle manager
app = FastAPI(root_path="/api", lifespan=lifespan)

# Dependency: Generates a new DB session for each request and closes it after completion
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# The @app.post decorator defines this function as a POST endpoint
# 'response_model=Tasks' tells FastAPI to format the outgoing data according to the Tasks schema
# 'status_code=201' ensures the API returns the standard HTTP status for a successful creation
@app.post("/tasks", response_model=Tasks, status_code=201)
async def create_new_task(
    task: NewTaskRequest,             # FastAPI parses the JSON body into this Pydantic model automatically
    db: Session = Depends(get_db)     # Injects the database session dependency we defined earlier
):
    # Step 1: Mapping
    # Convert the Pydantic model (DTO) to a dictionary and unpack it (**kwargs) 
    # into the SQLAlchemy Database Model (TaskDB)
    db_task = TaskDB(**task.model_dump())
    
    # Step 2: Staging
    # Add the object to the session. It isn't in the database yet, but SQLAlchemy is tracking it.
    db.add(db_task)       
    
    # Step 3: Persistence
    # Flush all changes in the session to the physical database and finalize the transaction
    db.commit()          
    
    # Step 4: Syncing
    # Re-fetch the object from the DB so we have the ID and timestamps generated by the server
    db.refresh(db_task)  
    
    # Step 5: Serialization
    # Convert the SQLAlchemy object attributes back into a NewTaskResponse Pydantic model
    return NewTaskResponse(**db_task.__dict__)

# The @app.get decorator defines this as a GET request handler
# 'response_model=GetAllTasksResponse' ensures the output matches our list schema
# 'status_code=200' is the standard HTTP code for a successful "OK" response
@app.get("/tasks", response_model=GetAllTasksResponse, status_code=200)
async def get_all_tasks(db: Session = Depends(get_db)):
    
    # Step 1: Query the Database
    # '.query(TaskDB)' selects the table, and '.all()' executes the fetch for all rows.
    # This returns a list of TaskDB objects (SQLAlchemy ORM instances).
    tasks = db.query(TaskDB).all()

    # Step 2: Prepare the Data
    # We create an empty list to hold our validated Pydantic objects.
    result = []

    # Step 3: Mapping (ORM to DTO)
    # Loop through each database row object.
    for task in tasks:
        # We convert the SQLAlchemy object's attributes (via __dict__) into 
        # a 'Tasks' Pydantic model. This handles the serialization and validation.
        result.append(Tasks(**task.__dict__))
    
    # Step 4: Final Response
    # Wrap the list in our 'GetAllTasksResponse' model so the final JSON 
    # looks like: {"tasks": [...]} instead of just a raw list.
    return GetAllTasksResponse(tasks=result)


# The @app.get decorator defines a GET endpoint with a path parameter '{id}'
# 'response_model=GetTaskByIdResponse' ensures the output matches the single task schema
# 'status_code=200' confirms the request was successful
@app.get("/tasks/{id}", response_model=GetTaskByIdResponse, status_code=200)
async def get_tasks_by_id(
    id: int,                          # FastAPI automatically converts the URL string to an integer
    db: Session = Depends(get_db)     # Injects the DB session dependency
):
    # Step 1: Database Query
    # '.query(TaskDB)' selects the table
    # '.filter(TaskDB.id == id)' adds a WHERE clause to match the primary key
    # '.first()' executes the query and returns the first result found (or None)
    task = db.query(TaskDB).filter(TaskDB.id == id).first()

    # Step 2: Existence Check
    # If no record was found in the database, task will be None
    if task is None:
        # Step 3: Error Handling
        # HTTPException immediately stops the function and sends a 404 response to the client
        raise HTTPException(
            status_code=404, 
            detail='Cannot find the item that is requested'
        )
    
    # Step 4: Successful Response
    # Map the database object attributes to the GetTaskByIdResponse Pydantic model
    return GetTaskByIdResponse(**task.__dict__)



# The @app.put decorator defines an update operation for a specific resource ID
@app.put("/tasks/{id}")
async def update_item(
    id: int,                          # The ID of the task to update from the URL
    task_data: UpdateTaskByIdRequest, # The new task data from the JSON request body
    db: Session = Depends(get_db)     # The database session dependency
):
    # Step 1: Input Validation
    # Ensure the ID and data body are present (FastAPI usually handles this, but extra checks are safe)
    if not id:
        raise HTTPException(status_code=400, detail="Invalid Request. Please check and try again")
    if not task_data:
        raise HTTPException(status_code=400, detail="Invalid Request. Please check and try again")
    
    # Step 2: Fetch Existing Record
    # We must find the record in the database before we can modify it
    task = db.query(TaskDB).filter(TaskDB.id == id).first()
    
    # If the task doesn't exist in the database, return a 404 error
    if not task:
        raise HTTPException(status_code=404, detail="Cannot find the item that is requested")
    
    # Step 3: Extract Update Data
    # 'exclude_unset=True' is crucial: it only includes fields actually sent in the request.
    # This prevents overwriting existing data with default null values.
    updated_data = task_data.model_dump(exclude_unset=True)
    
    # Step 4: Dynamic Mapping (Merging)
    # Loop through the dictionary of new data and apply changes to the database object
    for key, value in updated_data.items():
        # Security check: Do not allow the client to change the primary key ID
        if key == "id":
            continue
        # 'setattr' dynamically updates the attribute on the 'task' object (e.g., task.title = "New Title")
        setattr(task, key, value)
    
    # Step 5: Persist Changes
    db.add(task)        # Mark the object as modified in the session
    db.commit()         # Save the updates to the database
    db.refresh(task)    # Refresh to get the latest state (like the 'updated_on' timestamp)

    # Step 6: Return Response
    # Convert the updated database object back into the response Pydantic model
    return UpdateTaskByIdResponse(**task.__dict__)
    


# The @app.delete decorator defines a deletion endpoint for a specific resource
# 'status_code=204' is the REST standard for "No Content," meaning the action 
# was successful but there is no data to send back.
@app.delete("/items/{id}", status_code=204)
async def delete_item(
    id: int,                          # The ID of the item to be deleted from the URL
    db: Session = Depends(get_db)     # Injects the database session
):
    # Step 1: Basic Validation
    # Checks if the ID is provided (FastAPI usually ensures this via the path parameter)
    if not id:
        raise HTTPException(status_code=400, detail="Invalid Request. Please check and try again")
    
    # Step 2: Create a Query Cursor
    # We define the query but don't execute the final action yet. 
    # This 'cursor' allows us to perform multiple actions on the same filtered set.
    task_cursor = db.query(TaskDB).filter(TaskDB.id == id)
    
    # Step 3: Check for Existence
    # We execute .first() to see if the record actually exists before trying to delete it
    task = task_cursor.first()

    # If the record doesn't exist, we return a 404 to inform the client
    if not task: 
        raise HTTPException(status_code=404, detail="Cannot find the item that is requested")
    
    # Step 4: Execute Deletion
    # We call .delete() on the cursor. 
    # 'synchronize_session=False' is an optimization that tells SQLAlchemy 
    # not to update the local Python objects, as they are about to be discarded anyway.
    task_cursor.delete(synchronize_session=False)

    # Step 5: Finalize Transaction
    # Permanent removal from the database requires a commit
    db.commit()

    # Step 6: Empty Return
    # Since the status is 204, FastAPI ignores any return value and sends an empty body
    return